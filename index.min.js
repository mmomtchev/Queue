class Queue{constructor(_maxConcurrent,_minCycle){this.maxConcurrent=_maxConcurrent||1;this.minCycle=_minCycle||0;this.queueRunning=[];this.queueWaiting={};this.lastRun=0}dequeue(hash){const q=this.queueRunning;const idx=q.findIndex(x=>x.hash===hash);if(idx==-1)throw"queue desync";const o=q[idx];q.splice(idx,1);return o}getFirstWaiting(){for(let p of Object.keys(this.queueWaiting).sort((a,b)=>a-b))if(this.queueWaiting[p]!==undefined&&this.queueWaiting[p].length>0)return this.queueWaiting[p];return undefined}end(hash){const me=this.dequeue(hash);me.resolve();const q=this.getFirstWaiting();if(q!==undefined){const next=q.shift();next.resolve()}}async wait(hash,priority){let me={hash:hash,priority:priority};if(this.queueWaiting[priority]==undefined)this.queueWaiting[priority]=[];if(this.queueRunning.length>=this.maxConcurrent){me.promise=new Promise(resolve=>{me.resolve=resolve});this.queueWaiting[priority].push(me);await me.promise}this.queueRunning.push(me);me.promise=new Promise(resolve=>{me.resolve=resolve});while(Date.now()-this.lastRun<this.minCycle){await new Promise(resolve=>setTimeout(resolve,this.minCycle-Date.now()+this.lastRun))}this.lastRun=Date.now()}stat(){return{running:this.queueRunning.length,waiting:Object.keys(this.queueWaiting).reduce((t,x)=>t+=this.queueWaiting[x].length,0),last:this.lastRun}}async flush(){while(this.stat().waiting>0){for(let p of Object.keys(this.queueWaiting).sort((a,b)=>b-a)){const qp=this.queueWaiting[p];if(qp!==undefined&&qp.length>0){await qp[qp.length-1].promise}}}while(this.queueRunning.length>0){await Promise.allSettled(this.queueRunning.map(x=>x.promise))}}}module.exports=Queue;